<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content="https://machine-learning-blog.s3.eu-west-2.amazonaws.com/chronos_bedrock/architecture_diagram.png" name="thumbnail" />
<meta content="Zero-Shot Time Series Forecasting with Chronos using Amazon Bedrock and ClickHouse" name="description" />
<meta content="Time Series, LLM, Forecasting, Amazon Bedrock, Amazon Chronos" name="keywords" />

    <meta property="article:modified_time" content="2025-08-25T20:00:57+02:00" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LPMJ6R8T4C"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-LPMJ6R8T4C');
    </script>
    
    <title>Zero-Shot Time Series Forecasting with Chronos using Amazon Bedrock and ClickHouse &#8212; flaviagiammarino.com</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script src="../_static/documentation_options.js?v=73411916"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/custom.js"></script>
    <link rel="canonical" href="https://flaviagiammarino.com/blog/chronos_bedrock.html" />
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="&lt;no title&gt;" href="../index.html" /> 
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  
   
  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
             <section id="zero-shot-time-series-forecasting-with-chronos-using-amazon-bedrock-and-clickhouse">
<h1>Zero-Shot Time Series Forecasting with Chronos using Amazon Bedrock and ClickHouse<a class="headerlink" href="#zero-shot-time-series-forecasting-with-chronos-using-amazon-bedrock-and-clickhouse" title="Link to this heading">¶</a></h1>
<img
    src="https://machine-learning-blog.s3.eu-west-2.amazonaws.com/chronos_bedrock/architecture_diagram.png"
    style="width:100%"
><section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>The emergence of large language models (LLMs) with zero-shot generalization capabilities in sequence modelling
tasks has led to the development of time series foundation models (TSFMs) based on LLM architectures.
By representing time series as sequences of tokens, TSFMs can leverage LLMs’ capability to extrapolate future
patterns from the context data.
TSFMs eliminate the traditional need for domain-specific model development, allowing organizations to deploy
accurate time series solutions faster.</p>
<p>In this post, we will focus on Chronos, a family of TSFMs for time series forecasting developed by Amazon.
In contrast to other TSFMs, that rely on LLMs pre-trained on text, Chronos models are trained from scratch
on a large collection of time series datasets.
Moreover, unlike other TSFMs, which require fine-tuning on in-domain data, Chronos models generate accurate
zero-shot forecasts, without any task-specific adjustments.</p>
<p>Recently, the Chronos family of TSFMs has been extended with Chronos-Bolt, a faster, more accurate, and more
memory-efficient Chronos model that can also be used on CPU. Chronos-Bolt is available in AutoGluon-TimeSeries,
Amazon SageMaker JumpStart and Amazon Bedrock.</p>
<p>In the rest of this post, we will walk through a practical example of using Chronos-Bolt with time series data
stored in ClickHouse. We will create a Bedrock endpoint, then build a Lambda function that invokes the Bedrock
endpoint with context data queried from ClickHouse and returns the Chronos-Bolt forecasts.</p>
</section>
<section id="solution">
<h2>Solution<a class="headerlink" href="#solution" title="Link to this heading">¶</a></h2>
<p>In this particular example, we will work with the 15-minute time series of the Italian electricity system’s
total demand, which we downloaded from <a class="reference external" href="https://dati.terna.it/en/download-center#/load/total-load">Terna’s data portal</a>
and stored in a table in ClickHouse which we called <code class="docutils literal notranslate"><span class="pre">total_load_data</span></code>. However, given that Chronos-Bolt
doesn’t require any domain adaptation, the same solution can be applied to any other time series.</p>
<p><code class="docutils literal notranslate"><span class="pre">total_load_data</span></code></p>
<img
    src="https://machine-learning-blog.s3.eu-west-2.amazonaws.com/chronos_bedrock/time_series_data.png"
    style="width:80%"
><div class="admonition note">
<p class="admonition-title">Note</p>
<p>To be able to run the code below, you will need to have Boto3 and the AWS-CLI installed on your machine.
You will also need to update several variables in the code to reflect your AWS
configuration - such as your AWS account number, region, service roles, etc. - as will be outlined below.</p>
</div>
<section id="create-the-bedrock-endpoint">
<h3>Create the Bedrock endpoint<a class="headerlink" href="#create-the-bedrock-endpoint" title="Link to this heading">¶</a></h3>
<p>We start by deploying Chronos-Bolt to a Bedrock endpoint hosted on a CPU EC2 instance.
This can be done using <a class="reference external" href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/bedrock/client/create_marketplace_model_endpoint.html">Boto3</a>
as in the code below, with the <a class="reference external" href="https://docs.aws.amazon.com/cli/latest/reference/bedrock/create-marketplace-model-endpoint.html">AWS-CLI</a>,
or directly from the Bedrock console.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If using the code below, make sure to replace the following variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;&lt;bedrock-marketplace-arn&gt;&quot;</span></code>: The Bedrock marketplace ARN of Chronos-Bolt (Base) model.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;&lt;bedrock-execution-role&gt;&quot;</span></code>: The Bedrock execution role ARN.</p></li>
</ul>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">boto3</span>

<span class="c1"># Create the Bedrock client</span>
<span class="n">bedrock_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span><span class="s2">&quot;bedrock&quot;</span><span class="p">)</span>

<span class="c1"># Create the Bedrock endpoint</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">bedrock_client</span><span class="o">.</span><span class="n">create_marketplace_model_endpoint</span><span class="p">(</span>
    <span class="n">modelSourceIdentifier</span><span class="o">=</span><span class="s2">&quot;&lt;bedrock-marketplace-arn&gt;&quot;</span><span class="p">,</span>
    <span class="n">endpointConfig</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;sageMaker&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;initialInstanceCount&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;instanceType&quot;</span><span class="p">:</span> <span class="s2">&quot;ml.m5.4xlarge&quot;</span><span class="p">,</span>
            <span class="s2">&quot;executionRole&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;bedrock-execution-role&gt;&quot;</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="n">endpointName</span><span class="o">=</span><span class="s2">&quot;chronos-bedrock-endpoint&quot;</span><span class="p">,</span>
    <span class="n">acceptEula</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Get the Bedrock endpoint ARN</span>
<span class="n">bedrock_endpoint_arn</span> <span class="o">=</span> <span class="n">response</span><span class="p">[</span><span class="s2">&quot;marketplaceModelEndpoint&quot;</span><span class="p">][</span><span class="s2">&quot;endpointArn&quot;</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="create-the-lambda-function-for-invoking-the-bedrock-endpoint-with-clickhouse-data">
<h3>Create the Lambda function for invoking the Bedrock endpoint with ClickHouse data<a class="headerlink" href="#create-the-lambda-function-for-invoking-the-bedrock-endpoint-with-clickhouse-data" title="Link to this heading">¶</a></h3>
<p>We now build a Lambda function for invoking the Bedrock endpoint with time series data stored in ClickHouse.</p>
<section id="create-the-docker-image">
<h4>Create the Docker image<a class="headerlink" href="#create-the-docker-image" title="Link to this heading">¶</a></h4>
<p>In order to create the Lambda function’s Docker image in Elastic Container Registry (ECR), we need the following files:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">app.py</span></code>: The Python code of the Lambda function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>: The list of dependencies that need to be installed in the Docker container.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>: The file containing the instructions to build the Docker image.</p></li>
</ul>
<section id="app-py">
<h5><code class="docutils literal notranslate"><span class="pre">app.py</span></code><a class="headerlink" href="#app-py" title="Link to this heading">¶</a></h5>
<p>The Lambda function takes as input the following parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;initialization_timestamp&quot;</span></code>: The first timestamp for which the forecasts should be generated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;frequency&quot;</span></code>: The frequency of the time series, in number of minutes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;context_length&quot;</span></code>: The number past time series values (prior to <code class="docutils literal notranslate"><span class="pre">initialization_timestamp</span></code>) to use as context.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;prediction_length&quot;</span></code>: The number of future time series values (on and after <code class="docutils literal notranslate"><span class="pre">initialization_timestamp</span></code>) to predict.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;quantile_levels&quot;</span></code>: The quantiles to be predicted at each future time step.</p></li>
</ul>
<p>The Lambda function connects to ClickHouse using <a class="reference external" href="https://clickhouse.com/docs/integrations/python">ClickHouse Connect</a>
and loads the context data using the <code class="docutils literal notranslate"><span class="pre">query_df</span></code> method, which returns the query output in a Pandas Dataframe.
After that, the Lambda function invokes the Bedrock endpoint with the context data.
The Bedrock endpoint response includes the predicted mean and the predicted quantiles of the time series
at each future time step, which the Lambda function returns to the user in JSON format
together with the corresponding timestamps.</p>
<p>The Python code of the Lambda function is reported below.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before deploying the Lambda function, make sure to replace the following variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;&lt;clickhouse-host&gt;&quot;</span></code>: The ClickHouse host.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;&lt;clickhouse-user&gt;&quot;</span></code>: The ClickHouse username.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;&lt;clickhouse-password&gt;&quot;</span></code>: The ClickHouse password.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;&lt;bedrock-endpoint-arn&gt;&quot;</span></code>: The Bedrock endpoint ARN.</p></li>
</ul>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">boto3</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">clickhouse_connect</span>

<span class="k">def</span><span class="w"> </span><span class="nf">handler</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate zero-shot forecasts with Chronos-Bolt (Base) Amazon Bedrock endpoint using data stored in ClickHouse.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ========================================================================================================</span>
<span class="sd">    event: dict.</span>
<span class="sd">        A dictionary with the following keys:</span>

<span class="sd">        initialization_timestamp: str.</span>
<span class="sd">            The initialization timestamp of the forecasts, in ISO format (YYYY-MM-DD HH:mm:ss).</span>

<span class="sd">        frequency: int.</span>
<span class="sd">            The frequency of the time series, in minutes.</span>

<span class="sd">        context_length: int.</span>
<span class="sd">            The number of past time steps to use as context.</span>

<span class="sd">        prediction_length: int.</span>
<span class="sd">            The number of future time steps to predict.</span>

<span class="sd">        quantile_levels: list of float.</span>
<span class="sd">            The quantiles to be predicted at each future time step.</span>

<span class="sd">    context: AWS Lambda context object, see https://docs.aws.amazon.com/lambda/latest/dg/python-context.html.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create the ClickHouse client</span>
    <span class="n">clickhouse_client</span> <span class="o">=</span> <span class="n">clickhouse_connect</span><span class="o">.</span><span class="n">get_client</span><span class="p">(</span>
        <span class="n">host</span><span class="o">=</span><span class="s2">&quot;&lt;clickhouse-host&gt;&quot;</span><span class="p">,</span>
        <span class="n">user</span><span class="o">=</span><span class="s2">&quot;&lt;clickhouse-user&gt;&quot;</span><span class="p">,</span>
        <span class="n">password</span><span class="o">=</span><span class="s2">&quot;&lt;clickhouse-password&gt;&quot;</span><span class="p">,</span>
        <span class="n">secure</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Load the input data from ClickHouse</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">clickhouse_client</span><span class="o">.</span><span class="n">query_df</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            select</span>
<span class="s2">                timestamp,</span>
<span class="s2">                total_load</span>
<span class="s2">            from</span>
<span class="s2">                total_load_data</span>
<span class="s2">            where</span>
<span class="s2">                timestamp &lt; toDateTime(&#39;</span><span class="si">{</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;initialization_timestamp&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;)</span>
<span class="s2">            and</span>
<span class="s2">                timestamp &gt;= toDateTime(&#39;</span><span class="si">{</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;initialization_timestamp&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;) - INTERVAL </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;frequency&#39;</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;context_length&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> MINUTES</span>
<span class="s2">            order by</span>
<span class="s2">                timestamp asc</span>
<span class="s2">        &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Create the Bedrock client</span>
    <span class="n">bedrock_runtime_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span>
        <span class="n">service_name</span><span class="o">=</span><span class="s2">&quot;bedrock-runtime&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Invoke the Bedrock endpoint with the ClickHouse data</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">bedrock_runtime_client</span><span class="o">.</span><span class="n">invoke_model</span><span class="p">(</span>
        <span class="n">modelId</span><span class="o">=</span><span class="s2">&quot;&lt;bedrock-endpoint-arn&gt;&quot;</span><span class="p">,</span>
        <span class="n">body</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span>
            <span class="s2">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[{</span>
                <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;total_load&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="p">}],</span>
            <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;prediction_length&quot;</span><span class="p">:</span> <span class="n">event</span><span class="p">[</span><span class="s2">&quot;prediction_length&quot;</span><span class="p">],</span>
                <span class="s2">&quot;quantile_levels&quot;</span><span class="p">:</span> <span class="n">event</span><span class="p">[</span><span class="s2">&quot;quantile_levels&quot;</span><span class="p">],</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">)</span>

    <span class="c1"># Extract the forecasts</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;predictions&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Add the timestamps to the forecasts</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;timestamp&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="n">x</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="n">event</span><span class="p">[</span><span class="s2">&quot;initialization_timestamp&quot;</span><span class="p">],</span>
                <span class="n">periods</span><span class="o">=</span><span class="n">event</span><span class="p">[</span><span class="s2">&quot;prediction_length&quot;</span><span class="p">],</span>
                <span class="n">freq</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;frequency&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">min&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="p">}</span> <span class="o">|</span> <span class="n">predictions</span>

    <span class="c1"># Return the forecasts</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;statusCode&quot;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
        <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
    <span class="p">}</span>
</pre></div>
</div>
</section>
<section id="requirements-txt">
<h5><code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code><a class="headerlink" href="#requirements-txt" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> file with the list of dependencies is reported below.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">boto3</span><span class="o">==</span><span class="mf">1.34.84</span>
<span class="n">clickhouse_connect</span><span class="o">==</span><span class="mf">0.8.18</span>
<span class="n">pandas</span><span class="o">==</span><span class="mf">2.3.1</span>
</pre></div>
</div>
</section>
<section id="dockerfile">
<h5><code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code><a class="headerlink" href="#dockerfile" title="Link to this heading">¶</a></h5>
<p>The standard <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> using the Python 3.12 AWS base image for Lambda is also reported below.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>FROM<span class="w"> </span>amazon/aws-lambda-python:3.12

COPY<span class="w"> </span>requirements.txt<span class="w">  </span>.

RUN<span class="w"> </span>pip3<span class="w"> </span>install<span class="w"> </span>-r<span class="w"> </span>requirements.txt<span class="w"> </span>--target<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">LAMBDA_TASK_ROOT</span><span class="si">}</span><span class="s2">&quot;</span>

COPY<span class="w"> </span>app.py<span class="w"> </span><span class="si">${</span><span class="nv">LAMBDA_TASK_ROOT</span><span class="si">}</span>

CMD<span class="w"> </span><span class="o">[</span><span class="s2">&quot;app.handler&quot;</span><span class="o">]</span>
</pre></div>
</div>
</section>
</section>
<section id="build-the-docker-image-and-push-it-to-ecr">
<h4>Build the Docker image and push it to ECR<a class="headerlink" href="#build-the-docker-image-and-push-it-to-ecr" title="Link to this heading">¶</a></h4>
<p>When all the files are ready, we can build the Docker image and push it to ECR
with the AWS-CLI as shown in the <code class="docutils literal notranslate"><span class="pre">build_and_push.sh</span></code> script below.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before running the script, make sure to replace the following variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;aws-account-id&gt;&quot;</span></code>: The AWS account number.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;&lt;ecr-repository-region&gt;&quot;</span></code>: The region of the ECR repository.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;&lt;ecr-repository-name&gt;&quot;</span></code>: The name of the ECR repository.</p></li>
</ul>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">aws_account_id</span><span class="o">=</span><span class="s2">&quot;&lt;aws-account-id&gt;&quot;</span>
<span class="nv">region</span><span class="o">=</span><span class="s2">&quot;&lt;ecr-repository-region&gt;&quot;</span>
<span class="nv">algorithm_name</span><span class="o">=</span><span class="s2">&quot;&lt;ecr-repository-name&gt;&quot;</span>

aws<span class="w"> </span>ecr<span class="w"> </span>get-login-password<span class="w"> </span>--region<span class="w"> </span><span class="nv">$region</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>docker<span class="w"> </span>login<span class="w"> </span>--username<span class="w"> </span>AWS<span class="w"> </span>--password-stdin<span class="w"> </span><span class="nv">$aws_account_id</span>.dkr.ecr.<span class="nv">$region</span>.amazonaws.com

aws<span class="w"> </span>ecr<span class="w"> </span>describe-repositories<span class="w"> </span>--repository-names<span class="w"> </span><span class="si">${</span><span class="nv">algorithm_name</span><span class="si">}</span><span class="w"> </span><span class="o">||</span><span class="w"> </span>aws<span class="w"> </span>ecr<span class="w"> </span>create-repository<span class="w"> </span>--repository-name<span class="w"> </span><span class="si">${</span><span class="nv">algorithm_name</span><span class="si">}</span>

docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span><span class="nv">$algorithm_name</span><span class="w"> </span>.

docker<span class="w"> </span>tag<span class="w"> </span><span class="nv">$algorithm_name</span>:latest<span class="w"> </span><span class="nv">$aws_account_id</span>.dkr.ecr.<span class="nv">$region</span>.amazonaws.com/<span class="nv">$algorithm_name</span>:latest

docker<span class="w"> </span>push<span class="w"> </span><span class="nv">$aws_account_id</span>.dkr.ecr.<span class="nv">$region</span>.amazonaws.com/<span class="nv">$algorithm_name</span>:latest
</pre></div>
</div>
</section>
<section id="create-the-lambda-function-from-the-docker-image-in-ecr">
<h4>Create the Lambda function from the Docker Image in ECR<a class="headerlink" href="#create-the-lambda-function-from-the-docker-image-in-ecr" title="Link to this heading">¶</a></h4>
<p>After the Docker image has been pushed to ECR, we can create the Lambda function using <a class="reference external" href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/lambda/client/create_function.html">Boto3</a>
as in the code below, with the <a class="reference external" href="https://docs.aws.amazon.com/cli/latest/reference/lambda/create-function.html">AWS-CLI</a>,
or directly from the Lambda console.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If using the code below, make sure to replace the following variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;&lt;ecr-image-uri&gt;&quot;</span></code>: The URI of the ECR image with the code of the Lambda function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;&lt;lambda-execution-role&gt;&quot;</span></code>: The Lambda execution role ARN.</p></li>
</ul>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">boto3</span>

<span class="c1"># Create the Lambda client</span>
<span class="n">lambda_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span><span class="s2">&quot;lambda&quot;</span><span class="p">)</span>

<span class="c1"># Create the Lambda function</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">lambda_client</span><span class="o">.</span><span class="n">create_function</span><span class="p">(</span>
    <span class="n">FunctionName</span><span class="o">=</span><span class="s2">&quot;chronos-lambda-function&quot;</span><span class="p">,</span>
    <span class="n">PackageType</span><span class="o">=</span><span class="s2">&quot;Image&quot;</span><span class="p">,</span>
    <span class="n">Code</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;ImageUri&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;ecr-image-uri&gt;&quot;</span>
    <span class="p">},</span>
    <span class="n">Role</span><span class="o">=</span><span class="s2">&quot;&lt;lambda-execution-role&gt;&quot;</span><span class="p">,</span>
    <span class="n">Timeout</span><span class="o">=</span><span class="mi">900</span><span class="p">,</span>
    <span class="n">MemorySize</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
    <span class="n">Publish</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="invoke-the-lambda-function-and-generate-the-forecasts">
<h3>Invoke the Lambda function and generate the forecasts<a class="headerlink" href="#invoke-the-lambda-function-and-generate-the-forecasts" title="Link to this heading">¶</a></h3>
<p>After the Lambda function has been created, we can invoke it to generate the forecasts.</p>
<p>The code below defines a Python function which invokes the Lambda function with the
inputs discussed in the previous section and casts the Lambda function’s JSON output to Pandas Dataframe.</p>
<p>Next, the code makes two invocations: the first time it requests the forecasts over a
past time window for which historical data is already available, which allows us to assess how
close the forecasts are to the actual data, while the second time it requests the forecasts
over a future time window for which the data is not yet available.</p>
<p>In both cases, the Lambda function is invoked with a context window of 3 weeks to generate 1-day-ahead forecasts.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">io</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">boto3</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="k">def</span><span class="w"> </span><span class="nf">invoke_lambda_function</span><span class="p">(</span>
    <span class="n">initialization_timestamp</span><span class="p">,</span>
    <span class="n">frequency</span><span class="p">,</span>
    <span class="n">context_length</span><span class="p">,</span>
    <span class="n">prediction_length</span><span class="p">,</span>
    <span class="n">quantile_levels</span><span class="p">,</span>
    <span class="n">function_name</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Invoke the Lambda function that generates zero-shot forecasts with Chronos-Bolt (Base)</span>
<span class="sd">    Amazon Bedrock endpoint using data stored in ClickHouse.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ========================================================================================================</span>
<span class="sd">    initialization_timestamp: str.</span>
<span class="sd">        The initialization timestamp of the forecasts, in ISO format (YYYY-MM-DD HH:mm:ss).</span>

<span class="sd">    frequency: int.</span>
<span class="sd">        The frequency of the time series, in minutes.</span>

<span class="sd">    context_length: int.</span>
<span class="sd">        The number of past time steps to use as context.</span>

<span class="sd">    prediction_length: int.</span>
<span class="sd">        The number of future time steps to predict.</span>

<span class="sd">    quantile_levels: list of float.</span>
<span class="sd">        The quantiles to be predicted at each future time step.</span>

<span class="sd">    function_name: str.</span>
<span class="sd">        The name of the Lambda function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create the Lambda client</span>
    <span class="n">lambda_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span><span class="s2">&quot;lambda&quot;</span><span class="p">)</span>

    <span class="c1"># Invoke the Lambda function</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">lambda_client</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span>
        <span class="n">FunctionName</span><span class="o">=</span><span class="n">function_name</span><span class="p">,</span>
        <span class="n">Payload</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span>
            <span class="s2">&quot;initialization_timestamp&quot;</span><span class="p">:</span> <span class="n">initialization_timestamp</span><span class="p">,</span>
            <span class="s2">&quot;frequency&quot;</span><span class="p">:</span> <span class="n">frequency</span><span class="p">,</span>
            <span class="s2">&quot;prediction_length&quot;</span><span class="p">:</span> <span class="n">prediction_length</span><span class="p">,</span>
            <span class="s2">&quot;context_length&quot;</span><span class="p">:</span> <span class="n">context_length</span><span class="p">,</span>
            <span class="s2">&quot;quantile_levels&quot;</span><span class="p">:</span> <span class="n">quantile_levels</span>
        <span class="p">})</span>
    <span class="p">)</span>

    <span class="c1"># Extract the forecasts in a data frame</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Payload&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">())[</span><span class="s2">&quot;body&quot;</span><span class="p">]))</span>

    <span class="c1"># Return the forecasts</span>
    <span class="k">return</span> <span class="n">predictions</span>

<span class="c1"># Define the Lambda function name and input parameters</span>
<span class="n">frequency</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">context_length</span> <span class="o">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">3</span>
<span class="n">prediction_length</span> <span class="o">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">4</span>
<span class="n">quantile_levels</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>
<span class="n">function_name</span> <span class="o">=</span> <span class="s2">&quot;chronos-lambda-function&quot;</span>

<span class="c1"># Generate the forecasts over a past time window</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">invoke_lambda_function</span><span class="p">(</span>
    <span class="n">initialization_timestamp</span><span class="o">=</span><span class="s2">&quot;2025-08-17 00:00:00&quot;</span><span class="p">,</span>
    <span class="n">frequency</span><span class="o">=</span><span class="n">frequency</span><span class="p">,</span>
    <span class="n">context_length</span><span class="o">=</span><span class="n">context_length</span><span class="p">,</span>
    <span class="n">prediction_length</span><span class="o">=</span><span class="n">prediction_length</span><span class="p">,</span>
    <span class="n">quantile_levels</span><span class="o">=</span><span class="n">quantile_levels</span><span class="p">,</span>
    <span class="n">function_name</span><span class="o">=</span><span class="n">function_name</span>
<span class="p">)</span>

<span class="c1"># Generate the forecasts over a future time window</span>
<span class="n">forecasts</span> <span class="o">=</span> <span class="n">invoke_lambda_function</span><span class="p">(</span>
    <span class="n">initialization_timestamp</span><span class="o">=</span><span class="s2">&quot;2025-08-18 00:00:00&quot;</span><span class="p">,</span>
    <span class="n">frequency</span><span class="o">=</span><span class="n">frequency</span><span class="p">,</span>
    <span class="n">context_length</span><span class="o">=</span><span class="n">context_length</span><span class="p">,</span>
    <span class="n">prediction_length</span><span class="o">=</span><span class="n">prediction_length</span><span class="p">,</span>
    <span class="n">quantile_levels</span><span class="o">=</span><span class="n">quantile_levels</span><span class="p">,</span>
    <span class="n">function_name</span><span class="o">=</span><span class="n">function_name</span>
<span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">predictions</span></code></p>
<img
    src="https://machine-learning-blog.s3.eu-west-2.amazonaws.com/chronos_bedrock/predictions_table.png"
    style="width:90%"
><p><code class="docutils literal notranslate"><span class="pre">forecasts</span></code></p>
<img
    src="https://machine-learning-blog.s3.eu-west-2.amazonaws.com/chronos_bedrock/forecasts_table.png"
    style="width:90%"
></section>
<section id="compare-the-forecasts-to-the-historical-data-stored-in-clickhouse">
<h3>Compare the forecasts to the historical data stored in ClickHouse<a class="headerlink" href="#compare-the-forecasts-to-the-historical-data-stored-in-clickhouse" title="Link to this heading">¶</a></h3>
<p>Now that the forecasts have been generated, we can compare them to the historical data stored in ClickHouse.
We again use ClickHouse Connect to query the database and retrieve the results directly into a Pandas DataFrame.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">clickhouse_connect</span>

<span class="c1"># Create the ClickHouse client</span>
<span class="n">clickhouse_client</span> <span class="o">=</span> <span class="n">clickhouse_connect</span><span class="o">.</span><span class="n">get_client</span><span class="p">(</span>
    <span class="n">host</span><span class="o">=</span><span class="s2">&quot;&lt;clickhouse-host&gt;&quot;</span><span class="p">,</span>
    <span class="n">user</span><span class="o">=</span><span class="s2">&quot;&lt;clickhouse-user&gt;&quot;</span><span class="p">,</span>
    <span class="n">password</span><span class="o">=</span><span class="s2">&quot;&lt;clickhouse-password&gt;&quot;</span><span class="p">,</span>
    <span class="n">secure</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="c1"># Load the historical data from ClickHouse</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">clickhouse_client</span><span class="o">.</span><span class="n">query_df</span><span class="p">(</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    select</span>
<span class="sd">        timestamp,</span>
<span class="sd">        total_load</span>
<span class="sd">    from</span>
<span class="sd">        total_load_data</span>
<span class="sd">    where</span>
<span class="sd">        timestamp &gt;= toDateTime(&#39;2025-08-18 23:45:00&#39;) - INTERVAL 14 DAYS</span>
<span class="sd">    order by</span>
<span class="sd">        timestamp asc</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="p">)</span>

<span class="c1"># Outer join the historical data with the model outputs</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
    <span class="n">left</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
    <span class="n">right</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">predictions</span><span class="p">,</span> <span class="n">forecasts</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">on</span><span class="o">=</span><span class="s2">&quot;timestamp&quot;</span><span class="p">,</span>
    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The results show that the forecasts are closely aligned with the actual data,
demonstrating the model’s ability to generalize effectively in a zero-shot setting.
Despite a holiday occurring on the last Friday of the context window,
the model produces accurate forecasts for the subsequent Sunday
and correctly anticipates an increase in energy demand on the following Monday,
highlighting its strength in capturing complex temporal patterns.</p>
<img
    src="https://machine-learning-blog.s3.eu-west-2.amazonaws.com/chronos_bedrock/forecasts_plot.png"
    style="width:100%"
></section>
</section>
</section>

<div class="section ablog__blog_comments">
   
</div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo of "/>
            </a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;Copyright © 2025, Flavia Giammarino.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>